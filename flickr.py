import argparse
import atexit
import json
from functools import partial
import subprocess as sp
import logging
import logging.handlers
import multiprocessing as mp
import multiprocessing_logging
import soundfile as sf
from skvideo.io import vread
import sys
import re
import os
import sox

LOGGER = logging.getLogger('flickr-dataset')
LOGGER.setLevel(logging.DEBUG)

HTTP_ERR_PATTERN = re.compile(r'.*Server returned (4|5)(X|[0-9])(X|[0-9]).*')

def parse_arguments():
    """
    Parse arguments from the command line


    Returns:
        args:  Argument dictionary
               (Type: dict[str, str])
    """
    parser = argparse.ArgumentParser(description='Download Flickr dataset locally')

    parser.add_argument('-f',
                        '--ffmpeg',
                        dest='ffmpeg_path',
                        action='store',
                        type=str,
                        default='./bin/ffmpeg/ffmpeg',
                        help='Path to ffmpeg executable')

    parser.add_argument('-fp',
                        '--ffprobe',
                        dest='ffprobe_path',
                        action='store',
                        type=str,
                        default='./bin/ffmpeg/ffprobe',
                        help='Path to ffprobe executable')

    parser.add_argument('-ac',
                        '--audio-codec',
                        dest='audio_codec',
                        action='store',
                        type=str,
                        default='flac',
                        help='Name of audio codec used by ffmpeg to encode output audio')

    parser.add_argument('-asr',
                        '--audio-sample-rate',
                        dest='audio_sample_rate',
                        action='store',
                        type=int,
                        default=48000,
                        help='Target audio sample rate (in Hz)')

    parser.add_argument('-abd',
                        '--audio-bit-depth',
                        dest='audio_bit_depth',
                        action='store',
                        type=int,
                        default=16,
                        help='Target audio sample bit depth')

    parser.add_argument('-vc',
                        '--video-codec',
                        dest='video_codec',
                        action='store',
                        type=str,
                        default='h264',
                        help='Name of video codec used by ffmpeg to encode output audio')

    parser.add_argument('-af',
                        '--audio-format',
                        dest='audio_format',
                        action='store',
                        type=str,
                        default='flac',
                        help='Name of audio format used by ffmpeg for output audio')

    parser.add_argument('-vf',
                        '--video-format',
                        dest='video_format',
                        action='store',
                        type=str,
                        default='mp4',
                        help='Name of video format used by ffmpeg for output video')

    parser.add_argument('-vfr',
                        '--video-frame-rate',
                        dest='video_frame_rate',
                        action='store',
                        type=int,
                        default=30,
                        help='Target video frame rate (in fps)')

    parser.add_argument('-nr',
                        '--num-retries',
                        dest='num_retries',
                        action='store',
                        type=int,
                        default=10,
                        help='Number of retries when ffmpeg encounters an HTTP' \
                             'issue, which could be to unpredictable network behavior')
    parser.add_argument('-n',
                        '--num-workers',
                        dest='num_workers',
                        action='store',
                        type=int,
                        default=4,
                        help='Number of multiprocessing workers used to download videos')

    parser.add_argument('-nl',
                        '--no-logging',
                        dest='disable_logging',
                        action='store_true',
                        default=False,
                        help='Disables logging if flag enabled')

    parser.add_argument('-lp',
                        '--log-path',
                        dest='log_path',
                        action='store',
                        default=None,
                        help='Path to log file generated by this script. ' \
                             'By default, the path is "./flickr-soundnet-dl.log".')

    parser.add_argument('-v',
                        '--verbose',
                        dest='verbose',
                        action='store_true',
                        default=False,
                        help='Prints verbose info to stdout')

    parser.add_argument('dataset_path',
                        action='store',
                        type=str,
                        help='Path to file containing flickr video URLs')

    parser.add_argument('data_dir',
                        action='store',
                        type=str,
                        help='Path to directory where Flickr data will be stored')


    return vars(parser.parse_args())



class SubprocessError(Exception):
    """
    Exception object that contains information about an error that occurred
    when running a command line command with a subprocess.
    """
    def __init__(self, cmd, return_code, stdout, stderr, *args):
        msg = 'Got non-zero exit code ({1}) from command "{0}": {2}'
        if stderr.strip():
            err_msg = stderr
        else:
            err_msg = stdout
        msg = msg.format(cmd[0], return_code, err_msg)
        self.cmd = cmd
        self.cmd_return_code = return_code
        self.cmd_stdout = stdout
        self.cmd_stderr = stderr
        super(SubprocessError, self).__init__(msg, *args)

class FfmpegInvalidURLError(Exception):
    """
    Exception raised when a 4XX or 5XX error is returned when making a request
    """
    def __init__(self, url, error, *args):
        self.url = url
        self.error = error
        msg = 'Got error when making request to "{}": {}'.format(url, error)
        super(FfmpegInvalidURLError, self).__init__(msg, *args)


class FfmpegValidationError(Exception):
    """
    Exception object that is raised when `ffmpeg` output does not validate.
    """
    pass


class FfmpegUnopenableFileError(FfmpegValidationError):
    """
    Exception object that is raised when a file produced by `ffmpeg` cannot be opened
    """
    def __init__(self, filepath, e, *args):
        self.filepath = filepath
        self.open_error = e
        msg = "Output at {} could not be opened: {}".format(filepath, str(e))
        super(FfmpegValidationError, self).__init__( msg, *args)


def ffmpeg(ffmpeg_path, input_path, video_output_path=None,
           audio_output_path=None, input_args=None, video_output_args=None,
           audio_output_args=None, log_level='error', num_retries=10,
           validation_callback=None, validation_args=None):
    """
    Transform an input file using `ffmpeg`

    Args:
        ffmpeg_path:  Path to ffmpeg executable
                      (Type: str)

        input_path:   Path/URL to input file(s)
                      (Type: str or iterable)


    Keyword Args:
        video_output_path:    Path/URL to output video file. If None, no video
                              file will be produced.
                              (Type: str or None)

        audio_output_path:    Path/URL to output audio file. If None, no audio
                              file will be produced.
                              (Type: str or None)

        input_args:           Options/flags for input files
                              (Type: list[str])

        video_output_args:    Options/flags for output video files
                              (Type: list[str])

        audio_output_args:    Options/flags for output audio files
                              (Type: list[str])

        log_level:            ffmpeg logging level
                              (Type: str)

        num_retries:          Number of retries if ffmpeg encounters an HTTP issue
                              (Type: int)

        validation_callback:  Optional callback to validate outputs
                              (Type: function)

        validation_args:      Dictionary of additional keyword arguments that
                              will be passed to validation callback
                              (Type: dict[str, *])
    """

    if not (audio_output_path or video_output_path):
        raise ValueError('Must provide at least an audio or video output path')

    if not input_args:
        input_args = []
    if not audio_output_args:
        audio_output_args = []
    if not video_output_args:
        video_output_args = []

    if audio_output_path is not None and os.path.exists(audio_output_path):
        LOGGER.info('ffmpeg output file "{}" already exists.'.format(audio_output_path))
    if video_output_path is not None and os.path.exists(video_output_path):
        LOGGER.info('ffmpeg output file "{}" already exists.'.format(video_output_path))

    last_err = None
    for attempt in range(num_retries):
        try:
            args = [ffmpeg_path]
            # Add input arguments
            args += input_args + [ '-i', input_path]
            if video_output_path:
                # Add video arguments
                args += video_output_args + [video_output_path]
            if audio_output_path:
                # Add audio arguments
                args += ['-map', '0:1'] + audio_output_args + [audio_output_path]

            # Add logging arguments
            args += ['-loglevel', log_level]

            run_command(args)
            if video_output_path:
                LOGGER.info('Downloaded video to {}'.format(video_output_path))
            if audio_output_path:
                LOGGER.info('Downloaded audio to {}'.format(audio_output_path))

            # Validate if a callback was passed in
            if validation_callback is not None:
                validation_args = validation_args or {}
                validation_callback(video_output_path, audio_output_path, **validation_args)

                if video_output_path:
                    LOGGER.info('Video at {} validated'.format(video_output_path))
                if audio_output_path:
                    LOGGER.info('Audio at {} validated'.format(audio_output_path))
            break
        except SubprocessError as e:
            last_err = e
            stderr = e.cmd_stderr.rstrip()
            if HTTP_ERR_PATTERN.match(stderr):
                # Retry if we got a 4XX or 5XX, in case it was just a network issue
                last_err = FfmpegInvalidURLError(input_path, stderr)

            LOGGER.error(str(e) + '. Retrying...')
            if os.path.exists(audio_output_path):
                os.remove(audio_output_path)
            if os.path.exists(video_output_path):
                os.remove(video_output_path)
            continue

        except FfmpegValidationError as e:
            last_err = e
            if attempt < num_retries - 1:
                if os.path.exists(audio_output_path):
                    os.remove(audio_output_path)
                if os.path.exists(video_output_path):
                    os.remove(video_output_path)
            # Retry if the output did not validate
            LOGGER.info('{}. Retrying...'.format(e))
            continue
    else:
        error_msg = 'Maximum number of retries ({}) reached. Could not obtain inputs at {}. Error: {}'
        LOGGER.error(error_msg.format(num_retries, input_path, str(last_err)))

        raise last_err



def extract_flickr_id(url):
    """
    Extracts Flickr ID from video URL

    Args:
        url:  Flickr video URL
              (Type: str)

    Returns:
        flickr_id:  Flickr ID string
                    (Type: str)
    """
    return url.strip('/').split('/')[-4]


def download_video(url, ffmpeg_path, ffprobe_path, data_dir=None, video_output_path=None,
                   audio_output_path=None, skip_video=False, skip_audio=False,
                   start_time=None, max_duration=10,
                   audio_sample_rate=48000, video_frame_rate=30,
                   video_codec='h264', video_format='mp4',
                   audio_codec='flac', audio_format='flac', audio_bit_depth=16,
                   num_retries=None, ffmpeg_log_level='error'):
    """
    Download a Flickr video (with the audio and video separated).

    The audio will be saved in <data_dir>/audio and the video will be saved in
    <data_dir>/video.

    The output filename is of the format:
        <Flickr ID>_.<extension>

    Args:
        url:           Flickr video URL
                       (Type: str)

        ffmpeg_path:   Path to ffmpeg executable
                       (Type: str)

        ffprobe_path:  Path to ffprobe executable
                       (Type: str)

    Keyword Args:
        data_dir:           Output directory where video will be saved if output
                            path is not explicitly given
                            (Type: str)

        video_output_path:  Output path where video will be saved
                            (Type: str)

        audio_output_path:  Output path where audio will be saved
                            (Type: str)

        skip_video:         If True, video is not downloaded
                            (Type: bool)

        skip_audio:         If True, audio is not downloaded
                            (Type: bool)

        audio_codec:        Name of audio codec used by ffmpeg to encode
                            output audio
                            (Type: str)

        audio_format:       Name of audio container format used for output audio
                            (Type: str)

        audio_sample_rate:  Target audio sample rate (in Hz)
                            (Type: int)

        audio_bit_depth:    Target audio sample bit depth
                            (Type: int)

        video_codec:        Name of video codec used by ffmpeg to encode
                            output video
                            (Type: str)

        video_format:       Name of video container format used for output video
                            (Type: str)

        video_frame_rate:   Target video frame rate (in fps)
                            (Type: int)

        num_retries:        Number of attempts to download and process an audio
                            or video file with ffmpeg
                            (Type: int)


    Returns:
        video_filepath:  Filepath to video file
                         (Type: str)

        audio_filepath:  Filepath to audio file
                         (Type: str)
    """
    if skip_video and skip_audio:
        raise ValueError('Cannot skip both audio and video')

    flickr_id = extract_flickr_id(url)
    if not skip_video and not video_output_path:
        if not data_dir:
            raise ValueError('Must provide data directory or video output path')
        video_output_path = os.path.join(data_dir, 'video',
                                         '{}.{}'.format(flickr_id, video_format))
    if not skip_audio and not audio_output_path:
        if not data_dir:
            raise ValueError('Must provide data directory or audio output path')
        audio_output_path = os.path.join(data_dir, 'audio',
                                         '{}.{}'.format(flickr_id, audio_format))

    audio_info = {
        'sample_rate': audio_sample_rate,
        'channels': 2,
        'bitrate': audio_bit_depth,
        'encoding': audio_codec.upper(),
    }
    video_info = {
        "r_frame_rate": "{}/1".format(video_frame_rate),
        "avg_frame_rate": "{}/1".format(video_frame_rate),
        'codec_name': video_codec.lower(),
    }

    input_args = ['-n']
    if start_time is not None:
        input_args.append(str(start_time))
    audio_output_args = ['-t', str(max_duration),
                         '-ar', str(audio_sample_rate),
                         '-vn',
                         '-ac', str(audio_info['channels']),
                         '-sample_fmt', 's{}'.format(audio_bit_depth),
                         '-f', audio_format,
                         '-acodec', audio_codec]
    video_output_args = ['-t', str(max_duration),
                         '-f', video_format,
                         '-r', str(video_frame_rate),
                         '-vcodec', video_codec]
    ffmpeg(ffmpeg_path, url, video_output_path=video_output_path,
           audio_output_path=audio_output_path, input_args=input_args,
           video_output_args=video_output_args,
           audio_output_args=audio_output_args,
           validation_callback=validate,
           validation_args={'audio_info': audio_info,
                            'video_info': video_info,
                            'ffprobe_path': ffprobe_path},
           log_level=ffmpeg_log_level)


def download_flickr_video(url, data_dir, ffmpeg_path, ffprobe_path,
                          is_retry=False, audio_output_path=None,
                          video_output_path=None, **ffmpeg_cfg):
    """
    Downloads a Flickr video, retrying with an alternate URL if the given
    URL is invalid

    Args:
        url:           Flickr video URL
                       (Type: str)

        data_dir:      Output directory where video will be saved if output
                       path is not explicitly given
                       (Type: str)

        ffmpeg_path:   Path to ffmpeg executable
                       (Type: str)

        ffprobe_path:  Path to ffprobe executable
                       (Type: str)

    Keyword Args:
        is_retry:         If True, this invocation of the function is for retrying
                          a video download with an alternate URL. Should not be set
                          by user.
                          (Type: bool)

        **ffmpeg_cfg:  Download arguments used by ffmpeg

    """
    LOGGER.info('Attempting to download video from "{}"'.format(url))

    try:
        download_video(url, ffmpeg_path, ffprobe_path, data_dir=data_dir,
                       video_output_path=video_output_path,
                       audio_output_path=audio_output_path, **ffmpeg_cfg)

    except FfmpegInvalidURLError as e:
        if not is_retry:
            # If got 4XX or 5XX error, retry using direct download link
            flickr_id = extract_flickr_id(url)
            alt_url = 'https://www.flickr.com/video_download.gne?id={}'.format(flickr_id)


            video_output_path = os.path.join(data_dir, 'video', '{}.{}'.format(
                flickr_id, ffmpeg_cfg.get('video_format', 'mp4')))
            audio_output_path = os.path.join(data_dir, 'audio', '{}.{}'.format(
                flickr_id, ffmpeg_cfg.get('audio_format', 'flac')))

            info_msg = 'Could not download video at URL "{}". Retrying with "{}" instead.'
            LOGGER.info(info_msg.format(url, alt_url))

            download_flickr_video(alt_url, data_dir, ffmpeg_path, ffprobe_path,
                                  is_retry=True, video_output_path=video_output_path,
                                  audio_output_path=audio_output_path, **ffmpeg_cfg)
        else:
            flickr_id = url[url.index('=') + 1:]
            err_msg = 'Could not download video with Flickr ID {}'.format(flickr_id)
            LOGGER.error(err_msg)
    except Exception as e:
        LOGGER.error(e)
        flickr_id = extract_flickr_id(url)
        err_msg = 'Could not download video with Flickr ID {}'.format(flickr_id)
        LOGGER.error(err_msg)

    #except Exception:
        # Exception is already logged
        #pass
    #    raise


def run_command(cmd, **kwargs):
    """
    Run a command line command

    Args:
        cmd:       List of strings used in the command
                   (Type: list[str])

        **kwargs:  Keyword arguments to be passed to subprocess.Popen()

    Returns:
        stdout:       stdout string produced by running command
                      (Type: str)

        stderr:       stderr string produced by running command
                      (Type: str)

        return_code:  Exit/return code from running command
                      (Type: int)
    """
    proc = sp.Popen(cmd, stdout=sp.PIPE, stderr=sp.PIPE, **kwargs)
    stdout, stderr = proc.communicate()

    return_code = proc.returncode

    if return_code != 0:
        raise SubprocessError(cmd, return_code, stdout.decode(), stderr.decode())

    return stdout, stderr, return_code


def ffprobe(ffprobe_path, filepath):
    """
    Run ffprobe to analyse audio or video file

    Args:
        ffprobe_path:  Path to ffprobe executable
                       (Type: str)

        filepath:      Path to audio or video file to analyse
                       (Type: str)

    Returns:
        output:  JSON object returned by ffprobe
                 (Type: JSON comptiable dict)
    """
    cmd_format = '{} -v quiet -print_format json -show_format -show_streams {}'
    cmd = cmd_format.format(ffprobe_path, filepath).split()
    stdout, stderr, retcode = run_command(cmd)
    return json.loads(stdout)


def validate_audio(audio_filepath, audio_info):
    """
    Take audio file and sanity check basic info.

        Sample output from sox:
            {
                'bitrate': 16,
                'channels': 2,
                'encoding': 'FLAC',
                'num_samples': 440978,
                'sample_rate': 44100.0,
                'silent': False
            }

    Args:
        audio_filepath:   Path to output audio
                          (Type: str)

        audio_info:       Audio info dict
                          (Type: dict[str, *])
    """
    if not os.path.exists(audio_filepath):
        error_msg = 'Output file {} does not exist.'.format(audio_filepath)
        raise FfmpegValidationError(error_msg)

    # Check to see if we can open the file
    try:
        sf.read(audio_filepath)
    except Exception as e:
        raise FfmpegUnopenableFileError(audio_filepath, e)


    sox_info = sox.file_info.info(audio_filepath)

    for k, v in audio_info.items():
        output_v = sox_info[k]
        if v != output_v:
            error_msg = 'Output audio {} should have {} = {}, but got {}.'.format(audio_filepath, k, v, output_v)
            raise FfmpegValidationError(error_msg)


def validate_video(video_filepath, ffprobe_path, video_info):
    """
    Take video file and sanity check basic info.

    Args:
        video_filepath:  Path to output video file
                         (Type: str)

        ffprobe_path:    Path to ffprobe executable
                         (Type: str)

        video_info:      Video info dictionary
                         (Type: str)
    """
    import skvideo
    import skvideo.io

    if not os.path.exists(video_filepath):
        error_msg = 'Output file {} does not exist.'.format(video_filepath)
        raise FfmpegValidationError(error_msg)

    skvideo.setFFmpegPath(os.path.dirname(ffprobe_path))

    # Check to see if we can open the file
    try:
        skvideo.io.vread(video_filepath)
    except Exception as e:
        raise FfmpegUnopenableFileError(video_filepath, e)

    ffprobe_info = ffprobe(ffprobe_path, video_filepath)
    if not ffprobe_info:
        error_msg = 'Could not analyse {} with ffprobe'
        raise FfmpegValidationError(error_msg.format(video_filepath))

    # Get the video stream data
    if not ffprobe_info.get('streams'):
        error_msg = '{} has no video streams!'
        raise FfmpegValidationError(error_msg.format(video_filepath))
    ffprobe_info = next(stream for stream in ffprobe_info['streams'] if stream['codec_type'] == 'video')

    for k, v in video_info.items():
        output_v = ffprobe_info[k]

        # Convert numeric types to float, since we may get strings from ffprobe
        try:
            v = float(v)
        except ValueError:
            pass
        try:
            output_v = float(output_v)
        except ValueError:
            pass

        if v != output_v:
            error_msg = 'Output video {} should have {} = {}, but got {}.'.format(video_filepath, k, v, output_v)
            raise FfmpegValidationError(error_msg)


def validate(video_filepath, audio_filepath, video_info, audio_info, ffprobe_path):
    """
    Validates audio and/or video generated by ffmpeg.

    Args:
        audio_filepath:  Path to output audio. If None, audio is not validated.
                         (Type: str or None)

        video_filepath:  Path to output video file. If None, video is not validated.
                         (Type: str or None)

        video_info:      Video info dictionary
                         (Type: str or None)

        audio_info:      Audio info dict
                         (Type: dict[str, *] or None)

        ffprobe_path:    Path to ffprobe executable
                         (Type: str)
    """
    if video_filepath is not None:
        validate_video(video_filepath, ffprobe_path, video_info)
    if audio_filepath is not None:
        validate_audio(audio_filepath, audio_info)


def init_file_logger(logger, log_path=None):
    """
    Initializes logging to a file.

    Saves log to "flickr-soundnet-dl.log" in the current directory, and rotates them
    after they reach 1MiB.

    Args:
        logger:  Logger object
                 (Type: logging.Logger)

    Keyword Args:
        log_path:  Path to log file. If None, defaults to "flickr-soundnet-dl.log"
                   (Type: str or None)
    """
    # Set up file handler
    if not log_path:
        log_path = './flickr-soundnet-dl.log'
    handler = logging.handlers.RotatingFileHandler(log_path, maxBytes=2**20)
    handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)


def init_console_logger(logger, verbose=False):
    """
    Initializes logging to stdout

    Args:
        logger:  Logger object
                 (Type: logging.Logger)

    Keyword Args:
        verbose:  If true, prints verbose information to stdout. False by default.
                  (Type: bool)
    """
    # Log to stderr also
    stream_handler = logging.StreamHandler()
    if verbose:
        stream_handler.setLevel(logging.DEBUG)
    else:
        stream_handler.setLevel(logging.ERROR)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)


def download_flickr_dataset(dataset_path, data_dir, ffmpeg_path, ffprobe_path,
                            log_path=None, verbose=False, disable_logging=False,
                            num_workers=1, **ffmpeg_cfg):
    """
    Downloads Flickr dataset files

    Args:
        dataset_path:
        data_dir:      Output directory where video will be saved if output
                       path is not explicitly given
                       (Type: str)

        ffmpeg_path:   Path to ffmpeg executable
                       (Type: str)

        ffprobe_path:  Path to ffprobe executable
                       (Type: str)

    Keyword Args:
        log_path:         Path to log file. If None, defaults to "flickr-soundnet-dl.log"
                          (Type: str or None)

        verbose:          If True, prints detailed messages to console
                          (Type: bool)

        disable_logging:  If True, does not log to a file
                          (Type: bool)

        num_workers:      Number of multiprocessing workers used to download videos
                          (Type: int)

        **ffmpeg_cfg:     ffmpeg configurations
    """

    init_console_logger(LOGGER, verbose=verbose)
    if not disable_logging:
        init_file_logger(LOGGER, log_path=log_path)
    multiprocessing_logging.install_mp_handler()
    print(verbose)
    LOGGER.debug('Initialized logging.')

    audio_dir = os.path.join(data_dir, 'audio')
    video_dir = os.path.join(data_dir, 'video')

    if not os.path.isdir(audio_dir):
        os.makedirs(audio_dir)

    if not os.path.isdir(video_dir):
        os.makedirs(video_dir)

    pool = mp.Pool(num_workers)
    try:
        with open(dataset_path, 'r') as f:
            for line_idx, line in enumerate(f):
                url = line.strip()
                media_filename = extract_flickr_id(url)
                video_filepath = os.path.join(data_dir, 'video', media_filename + '.' + ffmpeg_cfg.get('video_format', 'mp4'))
                audio_filepath = os.path.join(data_dir, 'audio', media_filename + '.' + ffmpeg_cfg.get('audio_format', 'flac'))

                if os.path.exists(video_filepath) and os.path.exists(audio_filepath):
                    info_msg = 'Already downloaded video {}. Skipping.'
                    LOGGER.info(info_msg.format(media_filename))
                    continue

                worker_args = [url, data_dir, ffmpeg_path, ffprobe_path]
                pool.apply_async(partial(download_flickr_video, **ffmpeg_cfg), worker_args)

    except KeyboardInterrupt:
        LOGGER.info("Forcing exit.")
        exit()
    finally:
        try:
            pool.close()
            pool.join()
        except KeyboardInterrupt:
            LOGGER.info("Forcing exit.")
            exit()

    LOGGER.info('Finished downloading videos!')


if __name__ == '__main__':
    atexit.register(lambda: os.system('stty sane') if sys.stdin.isatty() else None)
    download_flickr_dataset(**parse_arguments())
